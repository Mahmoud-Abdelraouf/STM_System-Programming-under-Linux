<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Linux Memeory Manager: memory_manager.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Linux Memeory Manager
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">memory_manager.h File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Header file for the Memory Manager module.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;stdint.h&gt;</code><br />
<code>#include &quot;<a class="el" href="glthread_8h_source.html">glthread.h</a>&quot;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for memory_manager.h:</div>
<div class="dyncontent">
<div class="center"><img src="memory__manager_8h__incl.png" border="0" usemap="#amemory__manager_8h" alt=""/></div>
<map name="amemory__manager_8h" id="amemory__manager_8h">
<area shape="rect" title="Header file for the Memory Manager module." alt="" coords="16,5,169,31"/>
<area shape="rect" title=" " alt="" coords="5,79,76,104"/>
<area shape="poly" title=" " alt="" coords="86,33,59,69,55,66,82,29"/>
<area shape="rect" href="glthread_8h.html" title="Header file for the Generic Linked List Thread library." alt="" coords="101,79,189,104"/>
<area shape="poly" title=" " alt="" coords="103,29,130,66,126,69,99,33"/>
</map>
</div>
</div><div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><img src="memory__manager_8h__dep__incl.png" border="0" usemap="#amemory__manager_8hdep" alt=""/></div>
<map name="amemory__manager_8hdep" id="amemory__manager_8hdep">
<area shape="rect" title="Header file for the Memory Manager module." alt="" coords="5,5,159,31"/>
<area shape="rect" href="memory__manager_8c.html" title="Implementation file for the Memory Manager module." alt="" coords="6,79,158,104"/>
<area shape="poly" title=" " alt="" coords="85,44,85,79,79,79,79,44"/>
</map>
</div>
</div>
<p><a href="memory__manager_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structblock__meta__data__.html">block_meta_data_</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure representing metadata for a memory block.  <a href="structblock__meta__data__.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvm__page__.html">vm_page_</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure representing a virtual memory page.  <a href="structvm__page__.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvm__page__family__.html">vm_page_family_</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure representing a page family in virtual memory.  <a href="structvm__page__family__.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvm__page__for__families__.html">vm_page_for_families_</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure representing a virtual memory page containing families of memory structures.  <a href="structvm__page__for__families__.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a7e33ad2337bb751f178af9eebc45a84d" id="r_a7e33ad2337bb751f178af9eebc45a84d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7e33ad2337bb751f178af9eebc45a84d">MM_MAX_STRUCT_NAME</a>&#160;&#160;&#160;32</td></tr>
<tr class="separator:a7e33ad2337bb751f178af9eebc45a84d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56d7beb47f6bbf896e6f21fb09c73ec5" id="r_a56d7beb47f6bbf896e6f21fb09c73ec5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a56d7beb47f6bbf896e6f21fb09c73ec5">MAX_STRUCT_NAME_LEN</a>&#160;&#160;&#160;50</td></tr>
<tr class="separator:a56d7beb47f6bbf896e6f21fb09c73ec5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1144c25dd2f4ee38d1825adf4a316a27" id="r_a1144c25dd2f4ee38d1825adf4a316a27"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1144c25dd2f4ee38d1825adf4a316a27">MAX_FAMILIES_PER_VM_PAGE</a></td></tr>
<tr class="memdesc:a1144c25dd2f4ee38d1825adf4a316a27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of families that can be stored in a single virtual memory page.  <br /></td></tr>
<tr class="separator:a1144c25dd2f4ee38d1825adf4a316a27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac15f4fa9d6b78fc0ff539a7d1d4b64d2" id="r_ac15f4fa9d6b78fc0ff539a7d1d4b64d2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac15f4fa9d6b78fc0ff539a7d1d4b64d2">ITERATE_PAGE_FAMILIES_BEGIN</a>(vm_page_for_families_ptr,  curr)</td></tr>
<tr class="memdesc:ac15f4fa9d6b78fc0ff539a7d1d4b64d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro for beginning iteration over page families.  <br /></td></tr>
<tr class="separator:ac15f4fa9d6b78fc0ff539a7d1d4b64d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade62c3641f42fba45136e760112aca9c" id="r_ade62c3641f42fba45136e760112aca9c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ade62c3641f42fba45136e760112aca9c">ITERATE_PAGE_FAMILIES_END</a>(vm_page_for_families_ptr,  curr)</td></tr>
<tr class="memdesc:ade62c3641f42fba45136e760112aca9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro marking the end of iteration over families within a virtual memory page.  <br /></td></tr>
<tr class="separator:ade62c3641f42fba45136e760112aca9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac631f611777465204532dc3ab987b332" id="r_ac631f611777465204532dc3ab987b332"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac631f611777465204532dc3ab987b332">ITERATE_VM_PAGE_BEGIN</a>(vm_page_family_ptr,  curr)</td></tr>
<tr class="memdesc:ac631f611777465204532dc3ab987b332"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro to iterate over virtual memory pages beginning from the first page of a page family.  <br /></td></tr>
<tr class="separator:ac631f611777465204532dc3ab987b332"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a596be76ddc13d22fa0fe655e5dd58931" id="r_a596be76ddc13d22fa0fe655e5dd58931"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a596be76ddc13d22fa0fe655e5dd58931">ITERATE_VM_PAGE_END</a>(vm_page_family_ptr,  curr)</td></tr>
<tr class="memdesc:a596be76ddc13d22fa0fe655e5dd58931"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro marking the end of the iteration over virtual memory pages.  <br /></td></tr>
<tr class="separator:a596be76ddc13d22fa0fe655e5dd58931"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac163a8510af79f4a2e157f664a0a73cc" id="r_ac163a8510af79f4a2e157f664a0a73cc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac163a8510af79f4a2e157f664a0a73cc">ITERATE_VM_PAGE_ALL_BLOCKS_BEGIN</a>(vm_page_ptr,  curr)</td></tr>
<tr class="memdesc:ac163a8510af79f4a2e157f664a0a73cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro to begin iteration over all memory blocks within a virtual memory page.  <br /></td></tr>
<tr class="separator:ac163a8510af79f4a2e157f664a0a73cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54793f38cfc42b2f461e3b198efa9a1e" id="r_a54793f38cfc42b2f461e3b198efa9a1e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a54793f38cfc42b2f461e3b198efa9a1e">ITERATE_VM_PAGE_ALL_BLOCKS_END</a>(vm_page_ptr,  curr)</td></tr>
<tr class="memdesc:a54793f38cfc42b2f461e3b198efa9a1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro to end iteration over all memory blocks within a virtual memory page.  <br /></td></tr>
<tr class="separator:a54793f38cfc42b2f461e3b198efa9a1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53981175c7d4dcad912920a3ab7626ae" id="r_a53981175c7d4dcad912920a3ab7626ae"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a53981175c7d4dcad912920a3ab7626ae">offset_of</a>(container_structure,  field_name)&#160;&#160;&#160;  ((size_t)(&amp;((container_structure *)0)-&gt;field_name))</td></tr>
<tr class="memdesc:a53981175c7d4dcad912920a3ab7626ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro to calculate the offset of a field within a structure.  <br /></td></tr>
<tr class="separator:a53981175c7d4dcad912920a3ab7626ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b33c3f061b53c0229ff71ef0b291595" id="r_a8b33c3f061b53c0229ff71ef0b291595"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8b33c3f061b53c0229ff71ef0b291595">MM_GET_PAGE_FROM_META_BLOCK</a>(block_meta_data_ptr)&#160;&#160;&#160;  ((void *)((char *)(block_meta_data_ptr) - (block_meta_data_ptr)-&gt;offset))</td></tr>
<tr class="memdesc:a8b33c3f061b53c0229ff71ef0b291595"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro to retrieve the virtual memory page from a block's metadata.  <br /></td></tr>
<tr class="separator:a8b33c3f061b53c0229ff71ef0b291595"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99051f1c2b6af9de76a35dc7546fe60c" id="r_a99051f1c2b6af9de76a35dc7546fe60c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a99051f1c2b6af9de76a35dc7546fe60c">NEXT_META_BLOCK_BY_SIZE</a>(block_meta_data_ptr)</td></tr>
<tr class="memdesc:a99051f1c2b6af9de76a35dc7546fe60c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro to retrieve the metadata of the next block based on the current block's size.  <br /></td></tr>
<tr class="separator:a99051f1c2b6af9de76a35dc7546fe60c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac866fe97df08a8d286eafb8243cd63da" id="r_ac866fe97df08a8d286eafb8243cd63da"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac866fe97df08a8d286eafb8243cd63da">NEXT_META_BLOCK</a>(block_meta_data_ptr)&#160;&#160;&#160;((block_meta_data_ptr)-&gt;next_block)</td></tr>
<tr class="memdesc:ac866fe97df08a8d286eafb8243cd63da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro to get the pointer to the next metadata block.  <br /></td></tr>
<tr class="separator:ac866fe97df08a8d286eafb8243cd63da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3be8c5743e0cd0d83dc3b7802cbbe2fc" id="r_a3be8c5743e0cd0d83dc3b7802cbbe2fc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3be8c5743e0cd0d83dc3b7802cbbe2fc">PREV_META_BLOCK</a>(block_meta_data_ptr)&#160;&#160;&#160;((block_meta_data_ptr)-&gt;prev_block)</td></tr>
<tr class="memdesc:a3be8c5743e0cd0d83dc3b7802cbbe2fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro to get the pointer to the previous metadata block.  <br /></td></tr>
<tr class="separator:a3be8c5743e0cd0d83dc3b7802cbbe2fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cc1ec88cf052995c8c09a4cc9daf886" id="r_a4cc1ec88cf052995c8c09a4cc9daf886"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4cc1ec88cf052995c8c09a4cc9daf886">MARK_VM_PAGE_EMPTY</a>(vm_page_t_ptr)</td></tr>
<tr class="memdesc:a4cc1ec88cf052995c8c09a4cc9daf886"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro to mark a virtual memory page as empty.  <br /></td></tr>
<tr class="separator:a4cc1ec88cf052995c8c09a4cc9daf886"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add6df20638bfeb770280984d1a88dfe6" id="r_add6df20638bfeb770280984d1a88dfe6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#add6df20638bfeb770280984d1a88dfe6">mm_bind_blocks_for_allocation</a>(allocated_meta_block,  free_meta_block)</td></tr>
<tr class="memdesc:add6df20638bfeb770280984d1a88dfe6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binds metadata blocks for memory allocation.  <br /></td></tr>
<tr class="separator:add6df20638bfeb770280984d1a88dfe6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ddc0f810ab01f3747ae4793557a746b" id="r_a8ddc0f810ab01f3747ae4793557a746b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8ddc0f810ab01f3747ae4793557a746b">MAX_PAGE_ALLOCATABLE_MEMORY</a>(units)&#160;&#160;&#160;  (<a class="el" href="memory__manager_8c.html#ae68e468ad150ea915ed9a3b9d899e9df">mm_max_page_allocatable_memory</a>(units))</td></tr>
<tr class="memdesc:a8ddc0f810ab01f3747ae4793557a746b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro to calculate the maximum allocatable memory for a given number of units.  <br /></td></tr>
<tr class="separator:a8ddc0f810ab01f3747ae4793557a746b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a173309530f1b69ddabf71b33b75baf9f" id="r_a173309530f1b69ddabf71b33b75baf9f"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structblock__meta__data__.html">block_meta_data_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a173309530f1b69ddabf71b33b75baf9f">block_meta_data_t</a></td></tr>
<tr class="memdesc:a173309530f1b69ddabf71b33b75baf9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure representing metadata for a memory block.  <br /></td></tr>
<tr class="separator:a173309530f1b69ddabf71b33b75baf9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3781a6a3593d9877d1c25c4c8e3f1868" id="r_a3781a6a3593d9877d1c25c4c8e3f1868"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structvm__page__.html">vm_page_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3781a6a3593d9877d1c25c4c8e3f1868">vm_page_t</a></td></tr>
<tr class="memdesc:a3781a6a3593d9877d1c25c4c8e3f1868"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure representing a virtual memory page.  <br /></td></tr>
<tr class="separator:a3781a6a3593d9877d1c25c4c8e3f1868"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad146e732e35bec81b72c7437204e9ee8" id="r_ad146e732e35bec81b72c7437204e9ee8"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structvm__page__family__.html">vm_page_family_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad146e732e35bec81b72c7437204e9ee8">vm_page_family_t</a></td></tr>
<tr class="memdesc:ad146e732e35bec81b72c7437204e9ee8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure representing a page family in virtual memory.  <br /></td></tr>
<tr class="separator:ad146e732e35bec81b72c7437204e9ee8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cf10cad96e10ff9160b976e509f9462" id="r_a0cf10cad96e10ff9160b976e509f9462"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structvm__page__for__families__.html">vm_page_for_families_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0cf10cad96e10ff9160b976e509f9462">vm_page_for_families_t</a></td></tr>
<tr class="memdesc:a0cf10cad96e10ff9160b976e509f9462"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure representing a virtual memory page containing families of memory structures.  <br /></td></tr>
<tr class="separator:a0cf10cad96e10ff9160b976e509f9462"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a8137dde168b63da6dc080c3e41660743" id="r_a8137dde168b63da6dc080c3e41660743"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8137dde168b63da6dc080c3e41660743">vm_bool_t</a> { <a class="el" href="#a8137dde168b63da6dc080c3e41660743a5fa86d930835744d22245a6bef510f24">MM_FALSE</a> = 0
, <a class="el" href="#a8137dde168b63da6dc080c3e41660743a60caf413ecbcbf918d0b0e19c9772556">MM_TRUE</a> = 1
 }</td></tr>
<tr class="memdesc:a8137dde168b63da6dc080c3e41660743"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a boolean value.  <a href="#a8137dde168b63da6dc080c3e41660743">More...</a><br /></td></tr>
<tr class="separator:a8137dde168b63da6dc080c3e41660743"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aa604b0781f01e3696274d24e45a62ff2" id="r_aa604b0781f01e3696274d24e45a62ff2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa604b0781f01e3696274d24e45a62ff2">GLTHREAD_TO_STRUCT</a> (glthread_to_block_meta_data, <a class="el" href="#a173309530f1b69ddabf71b33b75baf9f">block_meta_data_t</a>, priority_thread_glue, glthread_ptr)</td></tr>
<tr class="memdesc:aa604b0781f01e3696274d24e45a62ff2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro to declare a conversion function for converting a glthread_t structure to a user-defined structure pointer.  <br /></td></tr>
<tr class="separator:aa604b0781f01e3696274d24e45a62ff2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf4906c4a2cd80f10a570cc1c7411111" id="r_acf4906c4a2cd80f10a570cc1c7411111"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a3781a6a3593d9877d1c25c4c8e3f1868">vm_page_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acf4906c4a2cd80f10a570cc1c7411111">allocate_vm_page</a> (<a class="el" href="#ad146e732e35bec81b72c7437204e9ee8">vm_page_family_t</a> *vm_page_family)</td></tr>
<tr class="memdesc:acf4906c4a2cd80f10a570cc1c7411111"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates a new virtual memory page for a given page family.  <br /></td></tr>
<tr class="separator:acf4906c4a2cd80f10a570cc1c7411111"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c0f19fa657602a76893a7f53e9f5222" id="r_a3c0f19fa657602a76893a7f53e9f5222"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3c0f19fa657602a76893a7f53e9f5222">mm_vm_page_delete_and_free</a> (<a class="el" href="#a3781a6a3593d9877d1c25c4c8e3f1868">vm_page_t</a> *vm_page)</td></tr>
<tr class="memdesc:a3c0f19fa657602a76893a7f53e9f5222"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes and frees a virtual memory page.  <br /></td></tr>
<tr class="separator:a3c0f19fa657602a76893a7f53e9f5222"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9910db7228c29ee672139e284cd6cec" id="r_ab9910db7228c29ee672139e284cd6cec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ad146e732e35bec81b72c7437204e9ee8">vm_page_family_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab9910db7228c29ee672139e284cd6cec">lookup_page_family_by_name</a> (char *struct_name)</td></tr>
<tr class="memdesc:ab9910db7228c29ee672139e284cd6cec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Looks up a page family by its name.  <br /></td></tr>
<tr class="separator:ab9910db7228c29ee672139e284cd6cec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38d0ee21c7b3b9b22289786fd969be46" id="r_a38d0ee21c7b3b9b22289786fd969be46"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a8137dde168b63da6dc080c3e41660743">vm_bool_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a38d0ee21c7b3b9b22289786fd969be46">mm_is_vm_page_empty</a> (<a class="el" href="#a3781a6a3593d9877d1c25c4c8e3f1868">vm_page_t</a> *vm_page)</td></tr>
<tr class="memdesc:a38d0ee21c7b3b9b22289786fd969be46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a virtual memory page is empty.  <br /></td></tr>
<tr class="separator:a38d0ee21c7b3b9b22289786fd969be46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa72156192006fd76902b0616def7db4d" id="r_aa72156192006fd76902b0616def7db4d"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa72156192006fd76902b0616def7db4d">mm_add_free_block_meta_data_to_free_block_list</a> (<a class="el" href="#ad146e732e35bec81b72c7437204e9ee8">vm_page_family_t</a> *vm_page_family, <a class="el" href="#a173309530f1b69ddabf71b33b75baf9f">block_meta_data_t</a> *free_block)</td></tr>
<tr class="memdesc:aa72156192006fd76902b0616def7db4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a free block's metadata to the free block list of a virtual memory page family.  <br /></td></tr>
<tr class="separator:aa72156192006fd76902b0616def7db4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a1f3a9753facffae61a89ed4ad4ff68" id="r_a0a1f3a9753facffae61a89ed4ad4ff68"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0a1f3a9753facffae61a89ed4ad4ff68">mm_print_vm_page_details</a> (<a class="el" href="#a3781a6a3593d9877d1c25c4c8e3f1868">vm_page_t</a> *vm_page)</td></tr>
<tr class="memdesc:a0a1f3a9753facffae61a89ed4ad4ff68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints details of a virtual memory page.  <br /></td></tr>
<tr class="separator:a0a1f3a9753facffae61a89ed4ad4ff68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b6e564655ddbbb3147b2d28ee398e5c" id="r_a8b6e564655ddbbb3147b2d28ee398e5c"><td class="memItemLeft" align="right" valign="top">static void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8b6e564655ddbbb3147b2d28ee398e5c">mm_get_new_vm_page_from_kernel</a> (int units)</td></tr>
<tr class="memdesc:a8b6e564655ddbbb3147b2d28ee398e5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates a new virtual memory page from the kernel.  <br /></td></tr>
<tr class="separator:a8b6e564655ddbbb3147b2d28ee398e5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7ac1212082ab9c61aab19e76696d9ec" id="r_ab7ac1212082ab9c61aab19e76696d9ec"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab7ac1212082ab9c61aab19e76696d9ec">mm_return_vm_page_to_kernel</a> (void *vm_page, int units)</td></tr>
<tr class="memdesc:ab7ac1212082ab9c61aab19e76696d9ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a virtual memory page to the kernel.  <br /></td></tr>
<tr class="separator:ab7ac1212082ab9c61aab19e76696d9ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b1f18097a67a303b6182eaf288b64f9" id="r_a8b1f18097a67a303b6182eaf288b64f9"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8b1f18097a67a303b6182eaf288b64f9">mm_union_free_blocks</a> (<a class="el" href="#a173309530f1b69ddabf71b33b75baf9f">block_meta_data_t</a> *first, <a class="el" href="#a173309530f1b69ddabf71b33b75baf9f">block_meta_data_t</a> *second)</td></tr>
<tr class="memdesc:a8b1f18097a67a303b6182eaf288b64f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merges two contiguous free memory blocks.  <br /></td></tr>
<tr class="separator:a8b1f18097a67a303b6182eaf288b64f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae68e468ad150ea915ed9a3b9d899e9df" id="r_ae68e468ad150ea915ed9a3b9d899e9df"><td class="memItemLeft" align="right" valign="top">static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae68e468ad150ea915ed9a3b9d899e9df">mm_max_page_allocatable_memory</a> (int units)</td></tr>
<tr class="memdesc:ae68e468ad150ea915ed9a3b9d899e9df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the maximum allocatable memory within a virtual memory page.  <br /></td></tr>
<tr class="separator:ae68e468ad150ea915ed9a3b9d899e9df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5987bb26622d19dcd8ecfd1416a7f3c6" id="r_a5987bb26622d19dcd8ecfd1416a7f3c6"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5987bb26622d19dcd8ecfd1416a7f3c6">free_blocks_comparison_function</a> (void *_block_meta_data1, void *_block_meta_data2)</td></tr>
<tr class="memdesc:a5987bb26622d19dcd8ecfd1416a7f3c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison function for sorting free blocks by block size.  <br /></td></tr>
<tr class="separator:a5987bb26622d19dcd8ecfd1416a7f3c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28b2162ebaea314c420ca44e29fb9d44" id="r_a28b2162ebaea314c420ca44e29fb9d44"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="#a173309530f1b69ddabf71b33b75baf9f">block_meta_data_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a28b2162ebaea314c420ca44e29fb9d44">mm_get_biggest_free_block_page_family</a> (<a class="el" href="#ad146e732e35bec81b72c7437204e9ee8">vm_page_family_t</a> *vm_page_family)</td></tr>
<tr class="memdesc:a28b2162ebaea314c420ca44e29fb9d44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the metadata of the biggest free memory block within a given virtual memory page family.  <br /></td></tr>
<tr class="separator:a28b2162ebaea314c420ca44e29fb9d44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab335253cb154c4adb2beb3cea638fb3c" id="r_ab335253cb154c4adb2beb3cea638fb3c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="#a8137dde168b63da6dc080c3e41660743">vm_bool_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab335253cb154c4adb2beb3cea638fb3c">mm_split_free_data_block_for_allocation</a> (<a class="el" href="#ad146e732e35bec81b72c7437204e9ee8">vm_page_family_t</a> *vm_page_family, <a class="el" href="#a173309530f1b69ddabf71b33b75baf9f">block_meta_data_t</a> *block_meta_data, uint32_t size)</td></tr>
<tr class="memdesc:ab335253cb154c4adb2beb3cea638fb3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits a free data block to allocate a portion of it for memory allocation.  <br /></td></tr>
<tr class="separator:ab335253cb154c4adb2beb3cea638fb3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a464ebae83b876a0ebb252e793e296fe9" id="r_a464ebae83b876a0ebb252e793e296fe9"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="#a173309530f1b69ddabf71b33b75baf9f">block_meta_data_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a464ebae83b876a0ebb252e793e296fe9">mm_allocate_free_data_block</a> (<a class="el" href="#ad146e732e35bec81b72c7437204e9ee8">vm_page_family_t</a> *vm_page_family, uint32_t req_size)</td></tr>
<tr class="memdesc:a464ebae83b876a0ebb252e793e296fe9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates a free data block from the specified page family.  <br /></td></tr>
<tr class="separator:a464ebae83b876a0ebb252e793e296fe9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf3ff2e7438d4ae2c531e8851b7270e8" id="r_acf3ff2e7438d4ae2c531e8851b7270e8"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="#a3781a6a3593d9877d1c25c4c8e3f1868">vm_page_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acf3ff2e7438d4ae2c531e8851b7270e8">mm_family_new_page_add</a> (<a class="el" href="#ad146e732e35bec81b72c7437204e9ee8">vm_page_family_t</a> *vm_page_family)</td></tr>
<tr class="memdesc:acf3ff2e7438d4ae2c531e8851b7270e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a new virtual memory page to the specified page family.  <br /></td></tr>
<tr class="separator:acf3ff2e7438d4ae2c531e8851b7270e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3635ea0217471faffe42b0c91c4bcc42" id="r_a3635ea0217471faffe42b0c91c4bcc42"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3635ea0217471faffe42b0c91c4bcc42">mm_get_hard_internal_memory_frag_size</a> (<a class="el" href="#a173309530f1b69ddabf71b33b75baf9f">block_meta_data_t</a> *first, <a class="el" href="#a173309530f1b69ddabf71b33b75baf9f">block_meta_data_t</a> *second)</td></tr>
<tr class="memdesc:a3635ea0217471faffe42b0c91c4bcc42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the size of hard internal memory fragmentation between two memory blocks.  <br /></td></tr>
<tr class="separator:a3635ea0217471faffe42b0c91c4bcc42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2250996fd809506caef0a6e61b6faebb" id="r_a2250996fd809506caef0a6e61b6faebb"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="#a173309530f1b69ddabf71b33b75baf9f">block_meta_data_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2250996fd809506caef0a6e61b6faebb">mm_free_blocks</a> (<a class="el" href="#a173309530f1b69ddabf71b33b75baf9f">block_meta_data_t</a> *to_be_free_block)</td></tr>
<tr class="memdesc:a2250996fd809506caef0a6e61b6faebb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees a memory block and performs merging if necessary.  <br /></td></tr>
<tr class="separator:a2250996fd809506caef0a6e61b6faebb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Header file for the Memory Manager module. </p>
<p>This file provides declarations for structures, macros, and functions used in the Memory Manager module. The Memory Manager is responsible for managing memory allocation and deallocation, including virtual memory page management, block metadata handling, and allocation algorithms. </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ac15f4fa9d6b78fc0ff539a7d1d4b64d2" name="ac15f4fa9d6b78fc0ff539a7d1d4b64d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac15f4fa9d6b78fc0ff539a7d1d4b64d2">&#9670;&#160;</a></span>ITERATE_PAGE_FAMILIES_BEGIN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ITERATE_PAGE_FAMILIES_BEGIN</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname">vm_page_for_families_ptr, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname">curr</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  {                                                                            \</div>
<div class="line">    uint32_t _count = 0;                                                       \</div>
<div class="line">    for (curr =                                                                \</div>
<div class="line">             (<a class="code hl_struct" href="structvm__page__family__.html">vm_page_family_t</a> *)&amp;vm_page_for_families_ptr-&gt;vm_page_family[0]; \</div>
<div class="line">         curr-&gt;struct_size &amp;&amp; _count &lt; <a class="code hl_define" href="#a1144c25dd2f4ee38d1825adf4a316a27">MAX_FAMILIES_PER_VM_PAGE</a>;               \</div>
<div class="line">         curr++, _count++) {</div>
<div class="ttc" id="amemory__manager_8h_html_a1144c25dd2f4ee38d1825adf4a316a27"><div class="ttname"><a href="#a1144c25dd2f4ee38d1825adf4a316a27">MAX_FAMILIES_PER_VM_PAGE</a></div><div class="ttdeci">#define MAX_FAMILIES_PER_VM_PAGE</div><div class="ttdoc">Maximum number of families that can be stored in a single virtual memory page.</div><div class="ttdef"><b>Definition</b> memory_manager.h:264</div></div>
<div class="ttc" id="astructvm__page__family___html"><div class="ttname"><a href="structvm__page__family__.html">vm_page_family_</a></div><div class="ttdoc">Structure representing a page family in virtual memory.</div><div class="ttdef"><b>Definition</b> memory_manager.h:118</div></div>
</div><!-- fragment -->
<p>Macro for beginning iteration over page families. </p>
<p>This macro is used to begin iteration over page families stored within a virtual memory page. It initializes a loop for iterating over page families, using the provided pointers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vm_page_for_families_ptr</td><td>Pointer to the virtual memory page for families. </td></tr>
    <tr><td class="paramname">curr</td><td>Pointer to the current page family being iterated.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This macro is typically used in conjunction with <code>ITERATE_PAGE_FAMILIES_END</code> to iterate over page families stored within a virtual memory page. The loop continues until all page families have been iterated or the maximum number of families per page is reached.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This macro assumes that <code>vm_page_for_families_ptr</code> points to a valid virtual memory page structure containing page families, and <code>curr</code> is a valid pointer to iterate over these families. Improper usage may result in undefined behavior.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ade62c3641f42fba45136e760112aca9c" title="Macro marking the end of iteration over families within a virtual memory page.">ITERATE_PAGE_FAMILIES_END</a> </dd></dl>

</div>
</div>
<a id="ade62c3641f42fba45136e760112aca9c" name="ade62c3641f42fba45136e760112aca9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade62c3641f42fba45136e760112aca9c">&#9670;&#160;</a></span>ITERATE_PAGE_FAMILIES_END</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ITERATE_PAGE_FAMILIES_END</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname">vm_page_for_families_ptr, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname">curr</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  }                                                                            \</div>
<div class="line">  }</div>
</div><!-- fragment -->
<p>Macro marking the end of iteration over families within a virtual memory page. </p>
<p>This macro is used to mark the end of iteration over families within a virtual memory page, which was started with the <code>ITERATE_PAGE_FAMILIES_BEGIN</code> macro. It concludes the loop for iterating over page families.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vm_page_for_families_ptr</td><td>Pointer to the virtual memory page for families. </td></tr>
    <tr><td class="paramname">curr</td><td>Pointer to the current family being iterated.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This macro should be used in conjunction with <code>ITERATE_PAGE_FAMILIES_BEGIN</code> to properly mark the end of the iteration loop over page families within a virtual memory page.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The loop for iterating over families within a virtual memory page should be enclosed within curly braces <code>{}</code> to ensure proper scoping of loop variables and statements. Improper usage of this macro may lead to compilation errors or unexpected behavior.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ac15f4fa9d6b78fc0ff539a7d1d4b64d2" title="Macro for beginning iteration over page families.">ITERATE_PAGE_FAMILIES_BEGIN</a> </dd></dl>

</div>
</div>
<a id="ac163a8510af79f4a2e157f664a0a73cc" name="ac163a8510af79f4a2e157f664a0a73cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac163a8510af79f4a2e157f664a0a73cc">&#9670;&#160;</a></span>ITERATE_VM_PAGE_ALL_BLOCKS_BEGIN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ITERATE_VM_PAGE_ALL_BLOCKS_BEGIN</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname">vm_page_ptr, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname">curr</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  <span class="keywordflow">do</span> {                                                                         \</div>
<div class="line">    curr = &amp;(vm_page_ptr-&gt;block_meta_data);                                    \</div>
<div class="line">    <a class="code hl_struct" href="structblock__meta__data__.html">block_meta_data_t</a> *next = NULL;                                            \</div>
<div class="line">    for (; curr != NULL; curr = next) {                                        \</div>
<div class="line">      next = <a class="code hl_define" href="#ac866fe97df08a8d286eafb8243cd63da">NEXT_META_BLOCK</a>(curr);</div>
<div class="ttc" id="amemory__manager_8h_html_ac866fe97df08a8d286eafb8243cd63da"><div class="ttname"><a href="#ac866fe97df08a8d286eafb8243cd63da">NEXT_META_BLOCK</a></div><div class="ttdeci">#define NEXT_META_BLOCK(block_meta_data_ptr)</div><div class="ttdoc">Macro to get the pointer to the next metadata block.</div><div class="ttdef"><b>Definition</b> memory_manager.h:469</div></div>
<div class="ttc" id="astructblock__meta__data___html"><div class="ttname"><a href="structblock__meta__data__.html">block_meta_data_</a></div><div class="ttdoc">Structure representing metadata for a memory block.</div><div class="ttdef"><b>Definition</b> memory_manager.h:52</div></div>
</div><!-- fragment -->
<p>Macro to begin iteration over all memory blocks within a virtual memory page. </p>
<p>This macro initializes the iteration process over all memory blocks within a given virtual memory page.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vm_page_ptr</td><td>Pointer to the virtual memory page. </td></tr>
    <tr><td class="paramname">curr</td><td>Pointer to hold the current memory block during iteration.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This macro is typically used in memory management systems to iterate over all memory blocks within a virtual memory page. It sets up a loop that traverses through the metadata blocks of each memory block within the page. The iteration begins with the metadata block of the first memory block in the page. </dd></dl>

</div>
</div>
<a id="a54793f38cfc42b2f461e3b198efa9a1e" name="a54793f38cfc42b2f461e3b198efa9a1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54793f38cfc42b2f461e3b198efa9a1e">&#9670;&#160;</a></span>ITERATE_VM_PAGE_ALL_BLOCKS_END</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ITERATE_VM_PAGE_ALL_BLOCKS_END</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname">vm_page_ptr, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname">curr</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  }                                                                            \</div>
<div class="line">  }                                                                            \</div>
<div class="line">  while (0)</div>
</div><!-- fragment -->
<p>Macro to end iteration over all memory blocks within a virtual memory page. </p>
<p>This macro marks the end of the iteration process over all memory blocks within a virtual memory page.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vm_page_ptr</td><td>Pointer to the virtual memory page. </td></tr>
    <tr><td class="paramname">curr</td><td>Pointer holding the current memory block during iteration.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This macro is used in conjunction with ITERATE_VM_PAGE_ALL_BLOCKS_BEGIN macro to define the end of the iteration loop. It completes the loop setup by ITERATE_VM_PAGE_ALL_BLOCKS_BEGIN, ensuring proper termination of the loop. </dd></dl>

</div>
</div>
<a id="ac631f611777465204532dc3ab987b332" name="ac631f611777465204532dc3ab987b332"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac631f611777465204532dc3ab987b332">&#9670;&#160;</a></span>ITERATE_VM_PAGE_BEGIN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ITERATE_VM_PAGE_BEGIN</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname">vm_page_family_ptr, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname">curr</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  {                                                                            \</div>
<div class="line">    curr = (vm_page_family_ptr)-&gt;first_page;                                   \</div>
<div class="line">    <a class="code hl_struct" href="structvm__page__.html">vm_page_t</a> *next = NULL;                                                    \</div>
<div class="line">    for (; curr != NULL; curr = next) {                                        \</div>
<div class="line">      next = curr-&gt;<a class="code hl_variable" href="structvm__page__.html#a87995cd55301183d3d7c94ae9cfc0bfb">next</a>;</div>
<div class="ttc" id="astructvm__page___html"><div class="ttname"><a href="structvm__page__.html">vm_page_</a></div><div class="ttdoc">Structure representing a virtual memory page.</div><div class="ttdef"><b>Definition</b> memory_manager.h:101</div></div>
<div class="ttc" id="astructvm__page___html_a87995cd55301183d3d7c94ae9cfc0bfb"><div class="ttname"><a href="structvm__page__.html#a87995cd55301183d3d7c94ae9cfc0bfb">vm_page_::next</a></div><div class="ttdeci">struct vm_page_ * next</div><div class="ttdef"><b>Definition</b> memory_manager.h:102</div></div>
</div><!-- fragment -->
<p>Macro to iterate over virtual memory pages beginning from the first page of a page family. </p>
<p>This macro allows for iterating over virtual memory pages starting from the first page of a specified page family.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vm_page_family_ptr</td><td>Pointer to the page family containing the first page. </td></tr>
    <tr><td class="paramname">curr</td><td>Pointer variable to hold the current virtual memory page during iteration. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a596be76ddc13d22fa0fe655e5dd58931" name="a596be76ddc13d22fa0fe655e5dd58931"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a596be76ddc13d22fa0fe655e5dd58931">&#9670;&#160;</a></span>ITERATE_VM_PAGE_END</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ITERATE_VM_PAGE_END</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname">vm_page_family_ptr, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname">curr</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  }                                                                            \</div>
<div class="line">  }</div>
</div><!-- fragment -->
<p>Macro marking the end of the iteration over virtual memory pages. </p>
<p>This macro marks the end of the iteration over virtual memory pages.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vm_page_family_ptr</td><td>Pointer to the page family containing the first page. </td></tr>
    <tr><td class="paramname">curr</td><td>Pointer variable holding the current virtual memory page. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4cc1ec88cf052995c8c09a4cc9daf886" name="a4cc1ec88cf052995c8c09a4cc9daf886"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cc1ec88cf052995c8c09a4cc9daf886">&#9670;&#160;</a></span>MARK_VM_PAGE_EMPTY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MARK_VM_PAGE_EMPTY</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname">vm_page_t_ptr</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  <span class="keywordflow">do</span> {                                                                         \</div>
<div class="line">    (vm_page_t_ptr)-&gt;block_meta_data.next_block = NULL;                        \</div>
<div class="line">    (vm_page_t_ptr)-&gt;block_meta_data.prev_block = NULL;                        \</div>
<div class="line">    (vm_page_t_ptr)-&gt;block_meta_data.is_free = <a class="code hl_enumvalue" href="#a8137dde168b63da6dc080c3e41660743a60caf413ecbcbf918d0b0e19c9772556">MM_TRUE</a>;                        \</div>
<div class="line">  } <span class="keywordflow">while</span> (0)</div>
<div class="ttc" id="amemory__manager_8h_html_a8137dde168b63da6dc080c3e41660743a60caf413ecbcbf918d0b0e19c9772556"><div class="ttname"><a href="#a8137dde168b63da6dc080c3e41660743a60caf413ecbcbf918d0b0e19c9772556">MM_TRUE</a></div><div class="ttdeci">@ MM_TRUE</div><div class="ttdef"><b>Definition</b> memory_manager.h:41</div></div>
</div><!-- fragment -->
<p>Macro to mark a virtual memory page as empty. </p>
<p>This macro is heavily documented to provide detailed information about its purpose, usage, and behavior.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vm_page_t_ptr</td><td>Pointer to the virtual memory page to be marked as empty.</td></tr>
  </table>
  </dd>
</dl>
<p>This macro is used to reset the state of a virtual memory page, indicating that it contains no allocated memory blocks and is available for reuse. It operates by modifying the metadata associated with the memory blocks within the page.</p>
<p>The macro takes a single parameter:</p><ul>
<li><code>vm_page_t_ptr:</code> Pointer to the virtual memory page to be marked as empty.</li>
</ul>
<p>The macro does the following:</p><ul>
<li>Sets the 'next_block' and 'prev_block' pointers of the block metadata to NULL, indicating that the page does not have any neighboring blocks.</li>
<li>Sets the 'is_free' flag of the block metadata to MM_TRUE, indicating that the page is free and available for allocation.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>This macro should be used judiciously and only when it is certain that the virtual memory page is not in use and can be safely reset. Incorrect usage may lead to memory corruption or undefined behavior.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>It is important to ensure that the 'vm_page_t_ptr' parameter is a valid pointer to a virtual memory page structure. Passing invalid or uninitialized pointers may result in undefined behavior.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This macro is typically used in memory management systems as part of memory recycling and allocation routines. It helps maintain memory hygiene by properly managing the state of virtual memory pages. </dd></dl>

</div>
</div>
<a id="a1144c25dd2f4ee38d1825adf4a316a27" name="a1144c25dd2f4ee38d1825adf4a316a27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1144c25dd2f4ee38d1825adf4a316a27">&#9670;&#160;</a></span>MAX_FAMILIES_PER_VM_PAGE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MAX_FAMILIES_PER_VM_PAGE</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  (<a class="code hl_variable" href="memory__manager_8c.html#a556910a8e507af29f88df82ead01d5af">SYSTEM_PAGE_SIZE</a> - <span class="keyword">sizeof</span>(<span class="keyword">struct </span><a class="code hl_struct" href="structvm__page__for__families__.html">vm_page_for_families_</a> *)) /                \</div>
<div class="line">      sizeof(<span class="keyword">struct</span> <a class="code hl_struct" href="structvm__page__family__.html">vm_page_family_</a>)</div>
<div class="ttc" id="amemory__manager_8c_html_a556910a8e507af29f88df82ead01d5af"><div class="ttname"><a href="memory__manager_8c.html#a556910a8e507af29f88df82ead01d5af">SYSTEM_PAGE_SIZE</a></div><div class="ttdeci">static size_t SYSTEM_PAGE_SIZE</div><div class="ttdoc">Size of the system page.</div><div class="ttdef"><b>Definition</b> memory_manager.c:47</div></div>
<div class="ttc" id="astructvm__page__for__families___html"><div class="ttname"><a href="structvm__page__for__families__.html">vm_page_for_families_</a></div><div class="ttdoc">Structure representing a virtual memory page containing families of memory structures.</div><div class="ttdef"><b>Definition</b> memory_manager.h:130</div></div>
</div><!-- fragment -->
<p>Maximum number of families that can be stored in a single virtual memory page. </p>
<p>This macro calculates the maximum number of families that can be stored in a single virtual memory page based on the system page size and the sizes of the <code>vm_page_for_families_t</code> and <code>vm_page_family_t</code> structures. It accounts for the space occupied by the <code>next</code> pointer in <code>vm_page_for_families_t</code>.</p>
<dl class="section note"><dt>Note</dt><dd>The calculation subtracts the size of the <code>next</code> pointer from the total system page size, and then divides the remaining size by the size of a single <code>vm_page_family_t</code> structure.</dd>
<dd>
This macro is useful for determining the maximum capacity of a virtual memory page for managing families of memory structures. </dd></dl>

</div>
</div>
<a id="a8ddc0f810ab01f3747ae4793557a746b" name="a8ddc0f810ab01f3747ae4793557a746b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ddc0f810ab01f3747ae4793557a746b">&#9670;&#160;</a></span>MAX_PAGE_ALLOCATABLE_MEMORY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MAX_PAGE_ALLOCATABLE_MEMORY</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname">units</span></td><td>)</td>
          <td>&#160;&#160;&#160;  (<a class="el" href="memory__manager_8c.html#ae68e468ad150ea915ed9a3b9d899e9df">mm_max_page_allocatable_memory</a>(units))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Macro to calculate the maximum allocatable memory for a given number of units. </p>
<p>This macro calculates the maximum allocatable memory for a specified number of units based on the system page size and the offset of the virtual memory page structure.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">units</td><td>Number of units for which memory allocation is requested. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Maximum allocatable memory in bytes.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This macro is typically used to determine the maximum amount of memory that can be allocated for a given number of units, considering system page constraints and structure offsets within the virtual memory page. </dd></dl>

</div>
</div>
<a id="a56d7beb47f6bbf896e6f21fb09c73ec5" name="a56d7beb47f6bbf896e6f21fb09c73ec5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56d7beb47f6bbf896e6f21fb09c73ec5">&#9670;&#160;</a></span>MAX_STRUCT_NAME_LEN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MAX_STRUCT_NAME_LEN&#160;&#160;&#160;50</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="add6df20638bfeb770280984d1a88dfe6" name="add6df20638bfeb770280984d1a88dfe6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add6df20638bfeb770280984d1a88dfe6">&#9670;&#160;</a></span>mm_bind_blocks_for_allocation</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define mm_bind_blocks_for_allocation</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname">allocated_meta_block, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname">free_meta_block</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  free_meta_block-&gt;prev_block = allocated_meta_block;                          \</div>
<div class="line">  free_meta_block-&gt;next_block = allocated_meta_block-&gt;next_block;              \</div>
<div class="line">  allocated_meta_block-&gt;next_block = free_meta_block;                          \</div>
<div class="line">  if (free_meta_block-&gt;next_block)                                             \</div>
<div class="line">  free_meta_block-&gt;next_block-&gt;prev_block = free_meta_block</div>
</div><!-- fragment -->
<p>Binds metadata blocks for memory allocation. </p>
<p>This macro is used to bind metadata blocks for memory allocation. It updates the pointers of the allocated and free blocks to maintain the integrity of the memory management system.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">allocated_meta_block</td><td>Pointer to the metadata block of the allocated memory. </td></tr>
    <tr><td class="paramname">free_meta_block</td><td>Pointer to the metadata block of the free memory.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This macro is typically used in memory management systems to properly link allocated and free memory blocks. It ensures correct traversal and management of memory blocks, maintaining the coherence of the memory allocation process. </dd></dl>

</div>
</div>
<a id="a8b33c3f061b53c0229ff71ef0b291595" name="a8b33c3f061b53c0229ff71ef0b291595"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b33c3f061b53c0229ff71ef0b291595">&#9670;&#160;</a></span>MM_GET_PAGE_FROM_META_BLOCK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MM_GET_PAGE_FROM_META_BLOCK</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname">block_meta_data_ptr</span></td><td>)</td>
          <td>&#160;&#160;&#160;  ((void *)((char *)(block_meta_data_ptr) - (block_meta_data_ptr)-&gt;offset))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Macro to retrieve the virtual memory page from a block's metadata. </p>
<p>This macro retrieves the virtual memory page associated with a given block's metadata.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block_meta_data_ptr</td><td>Pointer to the block's metadata. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the virtual memory page. </dd></dl>

</div>
</div>
<a id="a7e33ad2337bb751f178af9eebc45a84d" name="a7e33ad2337bb751f178af9eebc45a84d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e33ad2337bb751f178af9eebc45a84d">&#9670;&#160;</a></span>MM_MAX_STRUCT_NAME</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MM_MAX_STRUCT_NAME&#160;&#160;&#160;32</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>&lt; System includes &lt; External includes </p>

</div>
</div>
<a id="ac866fe97df08a8d286eafb8243cd63da" name="ac866fe97df08a8d286eafb8243cd63da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac866fe97df08a8d286eafb8243cd63da">&#9670;&#160;</a></span>NEXT_META_BLOCK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NEXT_META_BLOCK</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname">block_meta_data_ptr</span></td><td>)</td>
          <td>&#160;&#160;&#160;((block_meta_data_ptr)-&gt;next_block)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Macro to get the pointer to the next metadata block. </p>
<p>This macro is used to obtain the pointer to the next metadata block given a pointer to the current metadata block.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block_meta_data_ptr</td><td>Pointer to the current metadata block.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the next metadata block.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This macro is typically used in memory management systems where metadata blocks are used to manage memory allocation. It allows for efficient traversal of the metadata blocks linked list, enabling operations such as coalescing adjacent free memory blocks or iterating over allocated memory blocks. </dd></dl>

</div>
</div>
<a id="a99051f1c2b6af9de76a35dc7546fe60c" name="a99051f1c2b6af9de76a35dc7546fe60c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99051f1c2b6af9de76a35dc7546fe60c">&#9670;&#160;</a></span>NEXT_META_BLOCK_BY_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NEXT_META_BLOCK_BY_SIZE</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname">block_meta_data_ptr</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  ((<a class="code hl_struct" href="structblock__meta__data__.html">block_meta_data_t</a> *)((<span class="keywordtype">char</span> *)(block_meta_data_ptr + 1) +                   \</div>
<div class="line">                         (block_meta_data_ptr)-&gt;block_size))</div>
</div><!-- fragment -->
<p>Macro to retrieve the metadata of the next block based on the current block's size. </p>
<p>This macro calculates the pointer to the metadata of the next block by adding the size of the current block to the pointer to the current block's metadata.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block_meta_data_ptr</td><td>Pointer to the current block's metadata. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the metadata of the next block.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This macro is commonly used in memory management systems where metadata blocks are used to manage memory allocation. It allows for efficient traversal of the memory blocks, enabling operations such as coalescing adjacent free memory blocks or iterating over allocated memory blocks.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The behavior of this macro depends on the assumption that the next block starts immediately after the current block in memory. Ensure that the memory layout and block sizes are correctly managed to avoid undefined behavior. </dd></dl>

</div>
</div>
<a id="a53981175c7d4dcad912920a3ab7626ae" name="a53981175c7d4dcad912920a3ab7626ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53981175c7d4dcad912920a3ab7626ae">&#9670;&#160;</a></span>offset_of</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define offset_of</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname">container_structure, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname">field_name</span>&#160;)&#160;&#160;&#160;  ((size_t)(&amp;((container_structure *)0)-&gt;field_name))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Macro to calculate the offset of a field within a structure. </p>
<p>This macro calculates the byte offset of a specified field within a structure. It is often used in low-level programming to access structure members at specific memory locations.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">container_structure</td><td>The name of the structure containing the field. </td></tr>
    <tr><td class="paramname">field_name</td><td>The name of the field whose offset is being calculated.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The byte offset of the field within the structure.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This macro uses the pointer arithmetic to calculate the offset. </dd></dl>

</div>
</div>
<a id="a3be8c5743e0cd0d83dc3b7802cbbe2fc" name="a3be8c5743e0cd0d83dc3b7802cbbe2fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3be8c5743e0cd0d83dc3b7802cbbe2fc">&#9670;&#160;</a></span>PREV_META_BLOCK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PREV_META_BLOCK</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname">block_meta_data_ptr</span></td><td>)</td>
          <td>&#160;&#160;&#160;((block_meta_data_ptr)-&gt;prev_block)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Macro to get the pointer to the previous metadata block. </p>
<p>This macro is used to obtain the pointer to the previous metadata block given a pointer to the current metadata block.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block_meta_data_ptr</td><td>Pointer to the current metadata block.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the previous metadata block.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This macro is typically used in memory management systems where metadata blocks are used to manage memory allocation. It allows for efficient traversal of the metadata blocks linked list, allowing operations such as merging adjacent free memory blocks or finding neighboring blocks. </dd></dl>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a173309530f1b69ddabf71b33b75baf9f" name="a173309530f1b69ddabf71b33b75baf9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a173309530f1b69ddabf71b33b75baf9f">&#9670;&#160;</a></span>block_meta_data_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structblock__meta__data__.html">block_meta_data_</a> <a class="el" href="#a173309530f1b69ddabf71b33b75baf9f">block_meta_data_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Structure representing metadata for a memory block. </p>
<p>The <code>block_meta_data_t</code> structure represents metadata for a memory block. It includes information such as whether the block is free or allocated, its size, pointers to the previous and next blocks (if applicable), and the offset within the memory region. </p>

</div>
</div>
<a id="ad146e732e35bec81b72c7437204e9ee8" name="ad146e732e35bec81b72c7437204e9ee8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad146e732e35bec81b72c7437204e9ee8">&#9670;&#160;</a></span>vm_page_family_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structvm__page__family__.html">vm_page_family_</a> <a class="el" href="#ad146e732e35bec81b72c7437204e9ee8">vm_page_family_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Structure representing a page family in virtual memory. </p>
<p>This structure maintains information about a page family in virtual memory, including the name of the structure, its size, a pointer to the most recent virtual memory page in use, and a priority list of free memory blocks. </p>

</div>
</div>
<a id="a0cf10cad96e10ff9160b976e509f9462" name="a0cf10cad96e10ff9160b976e509f9462"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cf10cad96e10ff9160b976e509f9462">&#9670;&#160;</a></span>vm_page_for_families_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structvm__page__for__families__.html">vm_page_for_families_</a> <a class="el" href="#a0cf10cad96e10ff9160b976e509f9462">vm_page_for_families_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Structure representing a virtual memory page containing families of memory structures. </p>

</div>
</div>
<a id="a3781a6a3593d9877d1c25c4c8e3f1868" name="a3781a6a3593d9877d1c25c4c8e3f1868"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3781a6a3593d9877d1c25c4c8e3f1868">&#9670;&#160;</a></span>vm_page_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structvm__page__.html">vm_page_</a> <a class="el" href="#a3781a6a3593d9877d1c25c4c8e3f1868">vm_page_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Structure representing a virtual memory page. </p>
<p>This structure represents a virtual memory page used in memory management systems. It contains metadata for managing memory blocks within the page, as well as the actual memory region allocated for storing data blocks. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a8137dde168b63da6dc080c3e41660743" name="a8137dde168b63da6dc080c3e41660743"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8137dde168b63da6dc080c3e41660743">&#9670;&#160;</a></span>vm_bool_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#a8137dde168b63da6dc080c3e41660743">vm_bool_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents a boolean value. </p>
<p>The <code>vm_bool_t</code> type represents a boolean value, which can have one of two states: <code>VM_TRUE</code> or <code>VM_FALSE</code>. It is used to store boolean values in the program. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a8137dde168b63da6dc080c3e41660743a5fa86d930835744d22245a6bef510f24" name="a8137dde168b63da6dc080c3e41660743a5fa86d930835744d22245a6bef510f24"></a>MM_FALSE&#160;</td><td class="fielddoc"><p>Represents the false state. </p>
</td></tr>
<tr><td class="fieldname"><a id="a8137dde168b63da6dc080c3e41660743a60caf413ecbcbf918d0b0e19c9772556" name="a8137dde168b63da6dc080c3e41660743a60caf413ecbcbf918d0b0e19c9772556"></a>MM_TRUE&#160;</td><td class="fielddoc"><p>Represents the true state. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="acf4906c4a2cd80f10a570cc1c7411111" name="acf4906c4a2cd80f10a570cc1c7411111"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf4906c4a2cd80f10a570cc1c7411111">&#9670;&#160;</a></span>allocate_vm_page()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a3781a6a3593d9877d1c25c4c8e3f1868">vm_page_t</a> * allocate_vm_page </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ad146e732e35bec81b72c7437204e9ee8">vm_page_family_t</a> *</td>          <td class="paramname"><span class="paramname"><em>vm_page_family</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates a new virtual memory page for a given page family. </p>
<p>This function allocates a new virtual memory page for the specified page family. It initializes the metadata and pointers associated with the page and inserts the page into the linked list of pages belonging to the page family.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vm_page_family</td><td>Pointer to the page family for which the page is being allocated.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the newly allocated virtual memory page. </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="memory__manager_8h_acf4906c4a2cd80f10a570cc1c7411111_cgraph.png" border="0" usemap="#amemory__manager_8h_acf4906c4a2cd80f10a570cc1c7411111_cgraph" alt=""/></div>
<map name="amemory__manager_8h_acf4906c4a2cd80f10a570cc1c7411111_cgraph" id="amemory__manager_8h_acf4906c4a2cd80f10a570cc1c7411111_cgraph">
<area shape="rect" title="Allocates a new virtual memory page for a given page family." alt="" coords="5,63,147,88"/>
<area shape="rect" href="glthread_8c.html#a9e4b763220b1c69da2d9e9f191506f89" title="Initialize a glthread_t structure." alt="" coords="244,5,348,31"/>
<area shape="poly" title=" " alt="" coords="123,60,194,41,230,31,231,37,195,46,124,65"/>
<area shape="rect" href="memory__manager_8c.html#a8b6e564655ddbbb3147b2d28ee398e5c" title=" " alt="" coords="207,55,385,95"/>
<area shape="poly" title=" " alt="" coords="147,73,194,73,194,78,147,78"/>
<area shape="rect" href="memory__manager_8c.html#ae68e468ad150ea915ed9a3b9d899e9df" title=" " alt="" coords="195,119,397,159"/>
<area shape="poly" title=" " alt="" coords="122,86,214,113,213,118,120,91"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="memory__manager_8h_acf4906c4a2cd80f10a570cc1c7411111_icgraph.png" border="0" usemap="#amemory__manager_8h_acf4906c4a2cd80f10a570cc1c7411111_icgraph" alt=""/></div>
<map name="amemory__manager_8h_acf4906c4a2cd80f10a570cc1c7411111_icgraph" id="amemory__manager_8h_acf4906c4a2cd80f10a570cc1c7411111_icgraph">
<area shape="rect" title="Allocates a new virtual memory page for a given page family." alt="" coords="595,13,736,38"/>
<area shape="rect" href="memory__manager_8c.html#acf3ff2e7438d4ae2c531e8851b7270e8" title=" " alt="" coords="345,13,547,38"/>
<area shape="poly" title=" " alt="" coords="581,28,547,28,547,23,581,23"/>
<area shape="rect" href="memory__manager_8c.html#a464ebae83b876a0ebb252e793e296fe9" title=" " alt="" coords="121,5,297,45"/>
<area shape="poly" title=" " alt="" coords="332,28,298,28,298,23,332,23"/>
<area shape="rect" href="memory__manager_8c.html#a99f5a0d88caf5abe330155eb4e2d7aac" title="Allocates and initializes memory for an array of structures." alt="" coords="5,13,73,38"/>
<area shape="poly" title=" " alt="" coords="107,28,74,28,74,23,107,23"/>
</map>
</div>

</div>
</div>
<a id="a5987bb26622d19dcd8ecfd1416a7f3c6" name="a5987bb26622d19dcd8ecfd1416a7f3c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5987bb26622d19dcd8ecfd1416a7f3c6">&#9670;&#160;</a></span>free_blocks_comparison_function()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int free_blocks_comparison_function </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>_block_meta_data1</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>_block_meta_data2</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Comparison function for sorting free blocks by block size. </p>
<p>This function compares two block_meta_data_t objects based on their block sizes. It is intended to be used as a comparison function for sorting free blocks in descending order of block size.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_block_meta_data1</td><td>Pointer to the first block_meta_data_t object. </td></tr>
    <tr><td class="paramname">_block_meta_data2</td><td>Pointer to the second block_meta_data_t object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An integer value representing the result of the comparison:<ul>
<li>If the block size of _block_meta_data1 is greater than that of _block_meta_data2, the function returns -1.</li>
<li>If the block size of _block_meta_data1 is less than that of _block_meta_data2, the function returns 1.</li>
<li>If the block sizes are equal, the function returns 0. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="aa604b0781f01e3696274d24e45a62ff2" name="aa604b0781f01e3696274d24e45a62ff2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa604b0781f01e3696274d24e45a62ff2">&#9670;&#160;</a></span>GLTHREAD_TO_STRUCT()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GLTHREAD_TO_STRUCT </td>
          <td>(</td>
          <td class="paramtype">glthread_to_block_meta_data</td>          <td class="paramname"><span class="paramname">, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a173309530f1b69ddabf71b33b75baf9f">block_meta_data_t</a></td>          <td class="paramname"><span class="paramname">, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">priority_thread_glue</td>          <td class="paramname"><span class="paramname">, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">glthread_ptr</td>          <td class="paramname"><span class="paramname"></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Macro to declare a conversion function for converting a glthread_t structure to a user-defined structure pointer. </p>
<p>This macro simplifies the process of declaring a conversion function that takes a glthread_t pointer and returns a pointer to a user-defined structure. It is particularly useful when you have a glthread_t structure embedded within a user-defined structure and need to access the user-defined data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fn_name</td><td>The name of the conversion function to be declared. </td></tr>
    <tr><td class="paramname">struct_type</td><td>The type of the user-defined structure. </td></tr>
    <tr><td class="paramname">glthread_member</td><td>The name of the glthread_t member within the user-defined structure. </td></tr>
    <tr><td class="paramname">glthread_ptr</td><td>The name of the glthread_t pointer variable.</td></tr>
  </table>
  </dd>
</dl>
<p>Example usage: Suppose we have a user-defined structure named block_meta_data_t that contains a glthread_t member named priority_thread_glue. To declare a conversion function named glthread_to_block_meta_data to convert a glthread_t pointer to a block_meta_data_t pointer, we use the following declaration:</p>
<p><a class="el" href="#aa604b0781f01e3696274d24e45a62ff2" title="Macro to declare a conversion function for converting a glthread_t structure to a user-defined struct...">GLTHREAD_TO_STRUCT(glthread_to_block_meta_data, block_meta_data_t,
                   priority_thread_glue, glthread_ptr)</a>;</p>
<p>Now, we can use glthread_to_block_meta_data to convert glthread_t pointers to block_meta_data_t pointers and access the metadata associated with memory blocks. </p>

</div>
</div>
<a id="ab9910db7228c29ee672139e284cd6cec" name="ab9910db7228c29ee672139e284cd6cec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9910db7228c29ee672139e284cd6cec">&#9670;&#160;</a></span>lookup_page_family_by_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ad146e732e35bec81b72c7437204e9ee8">vm_page_family_t</a> * lookup_page_family_by_name </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>struct_name</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Looks up a page family by its name. </p>
<p>This function iterates over all virtual memory pages hosting page families and returns a pointer to the page family object identified by the given struct_name. If no such page family object is found, it returns NULL.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">struct_name</td><td>The name of the page family to look up.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the page family object if found, otherwise NULL.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function should be used to retrieve a page family object by its name after the page families have been registered and initialized using the appropriate functions and macros provided by the memory manager.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="memory__manager_8c.html#a0d0d58e2b3f34ada92ab7889d013e717" title="Initializes the memory manager.">mm_init</a> </dd>
<dd>
<a class="el" href="memory__manager__api_8h.html#a499d5d9d246e2afe4506e751ba45ec1e" title="Registers a memory structure for page family instantiation.">MM_REG_STRUCT</a> </dd>
<dd>
<a class="el" href="#a0cf10cad96e10ff9160b976e509f9462" title="Structure representing a virtual memory page containing families of memory structures.">vm_page_for_families_t</a> </dd>
<dd>
<a class="el" href="#ad146e732e35bec81b72c7437204e9ee8" title="Structure representing a page family in virtual memory.">vm_page_family_t</a> </dd></dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="memory__manager_8h_ab9910db7228c29ee672139e284cd6cec_icgraph.png" border="0" usemap="#amemory__manager_8h_ab9910db7228c29ee672139e284cd6cec_icgraph" alt=""/></div>
<map name="amemory__manager_8h_ab9910db7228c29ee672139e284cd6cec_icgraph" id="amemory__manager_8h_ab9910db7228c29ee672139e284cd6cec_icgraph">
<area shape="rect" title="Looks up a page family by its name." alt="" coords="328,35,481,75"/>
<area shape="rect" href="memory__manager_8c.html#a3ed96883ba6c4711318dbae3f5941bbf" title="Instantiates a new page family for a memory structure." alt="" coords="121,5,280,45"/>
<area shape="poly" title=" " alt="" coords="314,44,280,39,281,34,315,39"/>
<area shape="rect" href="memory__manager_8c.html#a99f5a0d88caf5abe330155eb4e2d7aac" title="Allocates and initializes memory for an array of structures." alt="" coords="5,42,73,67"/>
<area shape="poly" title=" " alt="" coords="314,59,280,60,121,60,74,59,74,53,121,55,280,55,314,54"/>
<area shape="poly" title=" " alt="" coords="108,45,74,51,73,46,107,40"/>
</map>
</div>

</div>
</div>
<a id="aa72156192006fd76902b0616def7db4d" name="aa72156192006fd76902b0616def7db4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa72156192006fd76902b0616def7db4d">&#9670;&#160;</a></span>mm_add_free_block_meta_data_to_free_block_list()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void mm_add_free_block_meta_data_to_free_block_list </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ad146e732e35bec81b72c7437204e9ee8">vm_page_family_t</a> *</td>          <td class="paramname"><span class="paramname"><em>vm_page_family</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a173309530f1b69ddabf71b33b75baf9f">block_meta_data_t</a> *</td>          <td class="paramname"><span class="paramname"><em>free_block</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a free block's metadata to the free block list of a virtual memory page family. </p>
<p>This function adds the metadata of a free block to the free block list of a virtual memory page family. The block metadata is inserted into the free block list in descending order of block size, based on the comparison function <code>free_blocks_comparison_function</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vm_page_family</td><td>Pointer to the virtual memory page family to which the free block metadata will be added. </td></tr>
    <tr><td class="paramname">free_block</td><td>Pointer to the block_meta_data_t structure representing the metadata of the free block to be added to the free block list.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function assumes that the <code>is_free</code> flag of the <code>free_block</code> structure is set to MM_TRUE. An assertion will trigger if this condition is not met. </dd></dl>

</div>
</div>
<a id="a464ebae83b876a0ebb252e793e296fe9" name="a464ebae83b876a0ebb252e793e296fe9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a464ebae83b876a0ebb252e793e296fe9">&#9670;&#160;</a></span>mm_allocate_free_data_block()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="#a173309530f1b69ddabf71b33b75baf9f">block_meta_data_t</a> * mm_allocate_free_data_block </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ad146e732e35bec81b72c7437204e9ee8">vm_page_family_t</a> *</td>          <td class="paramname"><span class="paramname"><em>vm_page_family</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>req_size</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocates a free data block from the specified page family. </p>
<p>This function attempts to allocate a free data block of the requested size from the specified page family. It first checks if there is a sufficiently large free block available within the page family. If not, it adds a new page to the page family to satisfy the allocation request. If successful, it splits the free block to allocate the requested memory and returns a pointer to the allocated block's metadata.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vm_page_family</td><td>Pointer to the page family from which to allocate the data block. </td></tr>
    <tr><td class="paramname">req_size</td><td>The size of the data block to allocate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the allocated block's metadata if successful, or NULL if the allocation fails.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function assumes that the specified page family has been properly initialized and that the requested size is within the maximum allocatable memory per page. It utilizes the mm_family_new_page_add and mm_split_free_data_block_for_allocation functions to add new pages and split free blocks for allocation, respectively. </dd></dl>

</div>
</div>
<a id="acf3ff2e7438d4ae2c531e8851b7270e8" name="acf3ff2e7438d4ae2c531e8851b7270e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf3ff2e7438d4ae2c531e8851b7270e8">&#9670;&#160;</a></span>mm_family_new_page_add()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="#a3781a6a3593d9877d1c25c4c8e3f1868">vm_page_t</a> * mm_family_new_page_add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ad146e732e35bec81b72c7437204e9ee8">vm_page_family_t</a> *</td>          <td class="paramname"><span class="paramname"><em>vm_page_family</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a new virtual memory page to the specified page family. </p>
<p>This function adds a new virtual memory page to the specified page family. It first allocates a new page using the allocate_vm_page function and then adds the page to the page family. Additionally, it treats the new page as one free block and adds its metadata to the free block list of the page family.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vm_page_family</td><td>Pointer to the page family to which the new page will be added.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the newly added virtual memory page if successful, or NULL if allocation fails.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function assumes that the page family has been properly initialized and that the allocate_vm_page function is available for allocating new pages. It also relies on the mm_add_free_block_meta_data_to_free_block_list function to add the metadata of the new page to the free block list of the page family. </dd></dl>

</div>
</div>
<a id="a2250996fd809506caef0a6e61b6faebb" name="a2250996fd809506caef0a6e61b6faebb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2250996fd809506caef0a6e61b6faebb">&#9670;&#160;</a></span>mm_free_blocks()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="#a173309530f1b69ddabf71b33b75baf9f">block_meta_data_t</a> * mm_free_blocks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a173309530f1b69ddabf71b33b75baf9f">block_meta_data_t</a> *</td>          <td class="paramname"><span class="paramname"><em>to_be_free_block</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Frees a memory block and performs merging if necessary. </p>
<p>This function frees a memory block represented by the given <code>to_be_free_block</code> parameter. It also handles merging of adjacent free blocks if present.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">to_be_free_block</td><td>The block to be freed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the freed block or NULL if the hosting page becomes empty.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The function assumes that <code>to_be_free_block</code> is not NULL and its is_free flag is set to MM_FALSE (indicating it's not already free). MM_H_ </dd></dl>

</div>
</div>
<a id="a28b2162ebaea314c420ca44e29fb9d44" name="a28b2162ebaea314c420ca44e29fb9d44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28b2162ebaea314c420ca44e29fb9d44">&#9670;&#160;</a></span>mm_get_biggest_free_block_page_family()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="#a173309530f1b69ddabf71b33b75baf9f">block_meta_data_t</a> * mm_get_biggest_free_block_page_family </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ad146e732e35bec81b72c7437204e9ee8">vm_page_family_t</a> *</td>          <td class="paramname"><span class="paramname"><em>vm_page_family</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the metadata of the biggest free memory block within a given virtual memory page family. </p>
<p>This function retrieves the metadata of the biggest free memory block within a specified virtual memory page family. It utilizes a priority list to maintain the biggest free block at the head of the list.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vm_page_family</td><td>Pointer to the virtual memory page family for which the biggest free block is to be retrieved.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the metadata of the biggest free memory block within the page family. If no such block exists (i.e., the priority list is empty), it returns NULL.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is typically used in memory management systems to efficiently locate the largest available free block within a page family, which can then be used for memory allocation. </dd></dl>

</div>
</div>
<a id="a3635ea0217471faffe42b0c91c4bcc42" name="a3635ea0217471faffe42b0c91c4bcc42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3635ea0217471faffe42b0c91c4bcc42">&#9670;&#160;</a></span>mm_get_hard_internal_memory_frag_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int mm_get_hard_internal_memory_frag_size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a173309530f1b69ddabf71b33b75baf9f">block_meta_data_t</a> *</td>          <td class="paramname"><span class="paramname"><em>first</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a173309530f1b69ddabf71b33b75baf9f">block_meta_data_t</a> *</td>          <td class="paramname"><span class="paramname"><em>second</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the size of hard internal memory fragmentation between two memory blocks. </p>
<p>This function calculates the size of hard internal memory fragmentation between two memory blocks. Hard internal memory fragmentation occurs when there is unused space between the end of the first memory block and the start of the second memory block.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>Pointer to the first memory block. </td></tr>
    <tr><td class="paramname">second</td><td>Pointer to the second memory block. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The size of hard internal memory fragmentation between the two memory blocks. </dd></dl>

</div>
</div>
<a id="a8b6e564655ddbbb3147b2d28ee398e5c" name="a8b6e564655ddbbb3147b2d28ee398e5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b6e564655ddbbb3147b2d28ee398e5c">&#9670;&#160;</a></span>mm_get_new_vm_page_from_kernel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void * mm_get_new_vm_page_from_kernel </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>units</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocates a new virtual memory page from the kernel. </p>
<p>This function allocates a new virtual memory page from the kernel and returns a pointer to the allocated memory block. It uses the <code>mmap()</code> system call to request the allocation of memory from the kernel.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">units</td><td>The number of memory pages to allocate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the allocated memory block, or NULL if the allocation fails.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The size of the allocated memory block is determined by multiplying the specified number of units by the system page size (defined by <code>SYSTEM_PAGE_SIZE</code>).</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function should be used with caution as it interacts directly with the kernel to allocate memory. Improper use or misuse of this function can lead to memory leaks or system instability.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>man mmap() </dd></dl>

</div>
</div>
<a id="a38d0ee21c7b3b9b22289786fd969be46" name="a38d0ee21c7b3b9b22289786fd969be46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38d0ee21c7b3b9b22289786fd969be46">&#9670;&#160;</a></span>mm_is_vm_page_empty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a8137dde168b63da6dc080c3e41660743">vm_bool_t</a> mm_is_vm_page_empty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a3781a6a3593d9877d1c25c4c8e3f1868">vm_page_t</a> *</td>          <td class="paramname"><span class="paramname"><em>vm_page</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if a virtual memory page is empty. </p>
<p>This function determines whether a virtual memory page is empty based on its metadata.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vm_page</td><td>Pointer to the virtual memory page to be checked.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>MM_TRUE if the page is empty.</li>
<li>MM_FALSE if the page is not empty or if the input pointer is NULL.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>A virtual memory page is considered empty if all the following conditions are met:<ul>
<li>The 'next_block' pointer in the block metadata is NULL, indicating no next block.</li>
<li>The 'prev_block' pointer in the block metadata is NULL, indicating no previous block.</li>
<li>The 'is_free' flag in the block metadata is set to MM_TRUE, indicating the page is free.</li>
</ul>
</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>It is important to ensure that the 'vm_page' parameter is a valid pointer to a virtual memory page structure. Passing invalid or uninitialized pointers may result in undefined behavior. </dd></dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="memory__manager_8h_a38d0ee21c7b3b9b22289786fd969be46_icgraph.png" border="0" usemap="#amemory__manager_8h_a38d0ee21c7b3b9b22289786fd969be46_icgraph" alt=""/></div>
<map name="amemory__manager_8h_a38d0ee21c7b3b9b22289786fd969be46_icgraph" id="amemory__manager_8h_a38d0ee21c7b3b9b22289786fd969be46_icgraph">
<area shape="rect" title="Checks if a virtual memory page is empty." alt="" coords="288,5,471,31"/>
<area shape="rect" href="memory__manager_8c.html#a2250996fd809506caef0a6e61b6faebb" title=" " alt="" coords="109,5,240,31"/>
<area shape="poly" title=" " alt="" coords="274,21,240,21,240,15,274,15"/>
<area shape="rect" href="memory__manager_8c.html#ae075bb556abb4342aedf495ddb8d390a" title="Frees memory allocated by the memory manager." alt="" coords="5,5,61,31"/>
<area shape="poly" title=" " alt="" coords="96,21,61,21,61,15,96,15"/>
</map>
</div>

</div>
</div>
<a id="ae68e468ad150ea915ed9a3b9d899e9df" name="ae68e468ad150ea915ed9a3b9d899e9df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae68e468ad150ea915ed9a3b9d899e9df">&#9670;&#160;</a></span>mm_max_page_allocatable_memory()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint32_t mm_max_page_allocatable_memory </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>units</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the maximum allocatable memory within a virtual memory page. </p>
<p>This function computes the maximum amount of memory that can be allocated within a virtual memory page, given the number of units specified.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">units</td><td>The number of memory units to be allocated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The maximum allocatable memory size in bytes.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function takes into account the size of the virtual memory page and subtracts the offset of the page memory within the vm_page_t structure to determine the available memory for allocation. It is typically used in memory management systems to ensure proper allocation of memory within virtual memory pages. </dd></dl>

</div>
</div>
<a id="a0a1f3a9753facffae61a89ed4ad4ff68" name="a0a1f3a9753facffae61a89ed4ad4ff68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a1f3a9753facffae61a89ed4ad4ff68">&#9670;&#160;</a></span>mm_print_vm_page_details()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mm_print_vm_page_details </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a3781a6a3593d9877d1c25c4c8e3f1868">vm_page_t</a> *</td>          <td class="paramname"><span class="paramname"><em>vm_page</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints details of a virtual memory page. </p>
<p>This function prints detailed information about a virtual memory page, including its next and previous pointers, page family name, and information about each block within the page.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vm_page</td><td>Pointer to the virtual memory page. </td></tr>
  </table>
  </dd>
</dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="memory__manager_8h_a0a1f3a9753facffae61a89ed4ad4ff68_icgraph.png" border="0" usemap="#amemory__manager_8h_a0a1f3a9753facffae61a89ed4ad4ff68_icgraph" alt=""/></div>
<map name="amemory__manager_8h_a0a1f3a9753facffae61a89ed4ad4ff68_icgraph" id="amemory__manager_8h_a0a1f3a9753facffae61a89ed4ad4ff68_icgraph">
<area shape="rect" title="Prints details of a virtual memory page." alt="" coords="349,5,552,31"/>
<area shape="rect" href="memory__manager_8c.html#a0107300bfc4db599504abef54c980fa6" title="Prints memory usage details related to the memory manager." alt="" coords="108,5,301,31"/>
<area shape="poly" title=" " alt="" coords="336,21,302,21,302,15,336,15"/>
<area shape="rect" href="memory__manager__test_8c.html#a3c04138a5bfe5d72780bb7e82a18e627" title="The main function." alt="" coords="5,5,60,31"/>
<area shape="poly" title=" " alt="" coords="94,21,60,21,60,15,94,15"/>
</map>
</div>

</div>
</div>
<a id="ab7ac1212082ab9c61aab19e76696d9ec" name="ab7ac1212082ab9c61aab19e76696d9ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7ac1212082ab9c61aab19e76696d9ec">&#9670;&#160;</a></span>mm_return_vm_page_to_kernel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void mm_return_vm_page_to_kernel </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>vm_page</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>units</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a virtual memory page to the kernel. </p>
<p>This function returns a virtual memory page previously allocated from the kernel back to the kernel. It uses the <code>munmap()</code> system call to release the memory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vm_page</td><td>A pointer to the memory block to be returned to the kernel. </td></tr>
    <tr><td class="paramname">units</td><td>The number of memory pages to return to the kernel.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The size of the memory block to be returned is determined by multiplying the specified number of units by the system page size (defined by <code>SYSTEM_PAGE_SIZE</code>).</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function should be used with caution as it interacts directly with the kernel to release memory. Improper use or misuse of this function can lead to memory leaks or system instability.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>man munmap() </dd></dl>

</div>
</div>
<a id="ab335253cb154c4adb2beb3cea638fb3c" name="ab335253cb154c4adb2beb3cea638fb3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab335253cb154c4adb2beb3cea638fb3c">&#9670;&#160;</a></span>mm_split_free_data_block_for_allocation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="#a8137dde168b63da6dc080c3e41660743">vm_bool_t</a> mm_split_free_data_block_for_allocation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ad146e732e35bec81b72c7437204e9ee8">vm_page_family_t</a> *</td>          <td class="paramname"><span class="paramname"><em>vm_page_family</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a173309530f1b69ddabf71b33b75baf9f">block_meta_data_t</a> *</td>          <td class="paramname"><span class="paramname"><em>block_meta_data</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Splits a free data block to allocate a portion of it for memory allocation. </p>
<p>This function splits a free data block to allocate a portion of it for memory allocation. It checks various cases to determine how the block should be split and whether additional metadata blocks need to be created. After splitting, it updates the metadata of the original block and, if necessary, creates new metadata blocks for the remaining free space.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vm_page_family</td><td>Pointer to the page family associated with the data block. </td></tr>
    <tr><td class="paramname">block_meta_data</td><td>Pointer to the metadata of the free data block to be split. </td></tr>
    <tr><td class="paramname">size</td><td>Size of the portion of the block to be allocated.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>MM_TRUE if the block is successfully split and allocated, MM_FALSE otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function assumes that the provided block is free and that the size argument specifies a valid size for memory allocation. It relies on the mm_bind_blocks_for_allocation function to establish the link between metadata blocks after splitting. </dd></dl>

</div>
</div>
<a id="a8b1f18097a67a303b6182eaf288b64f9" name="a8b1f18097a67a303b6182eaf288b64f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b1f18097a67a303b6182eaf288b64f9">&#9670;&#160;</a></span>mm_union_free_blocks()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void mm_union_free_blocks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a173309530f1b69ddabf71b33b75baf9f">block_meta_data_t</a> *</td>          <td class="paramname"><span class="paramname"><em>first</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a173309530f1b69ddabf71b33b75baf9f">block_meta_data_t</a> *</td>          <td class="paramname"><span class="paramname"><em>second</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Merges two contiguous free memory blocks. </p>
<p>This function merges two contiguous free memory blocks into a single block. The function assumes that both blocks are free and contiguous.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>Pointer to the first free memory block. </td></tr>
    <tr><td class="paramname">second</td><td>Pointer to the second free memory block.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is typically used in memory management systems to optimize memory usage by consolidating adjacent free memory blocks. </dd></dl>

</div>
</div>
<a id="a3c0f19fa657602a76893a7f53e9f5222" name="a3c0f19fa657602a76893a7f53e9f5222"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c0f19fa657602a76893a7f53e9f5222">&#9670;&#160;</a></span>mm_vm_page_delete_and_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mm_vm_page_delete_and_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a3781a6a3593d9877d1c25c4c8e3f1868">vm_page_t</a> *</td>          <td class="paramname"><span class="paramname"><em>vm_page</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deletes and frees a virtual memory page. </p>
<p>This function deletes and frees a virtual memory page. It removes the page from the linked list of pages belonging to its page family and deallocates the memory associated with the page.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vm_page</td><td>Pointer to the virtual memory page to be deleted and freed. </td></tr>
  </table>
  </dd>
</dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="memory__manager_8h_a3c0f19fa657602a76893a7f53e9f5222_cgraph.png" border="0" usemap="#amemory__manager_8h_a3c0f19fa657602a76893a7f53e9f5222_cgraph" alt=""/></div>
<map name="amemory__manager_8h_a3c0f19fa657602a76893a7f53e9f5222_cgraph" id="amemory__manager_8h_a3c0f19fa657602a76893a7f53e9f5222_cgraph">
<area shape="rect" title="Deletes and frees a virtual memory page." alt="" coords="5,13,232,38"/>
<area shape="rect" href="memory__manager_8c.html#ab7ac1212082ab9c61aab19e76696d9ec" title=" " alt="" coords="280,5,461,45"/>
<area shape="poly" title=" " alt="" coords="232,23,266,23,266,28,232,28"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="memory__manager_8h_a3c0f19fa657602a76893a7f53e9f5222_icgraph.png" border="0" usemap="#amemory__manager_8h_a3c0f19fa657602a76893a7f53e9f5222_icgraph" alt=""/></div>
<map name="amemory__manager_8h_a3c0f19fa657602a76893a7f53e9f5222_icgraph" id="amemory__manager_8h_a3c0f19fa657602a76893a7f53e9f5222_icgraph">
<area shape="rect" title="Deletes and frees a virtual memory page." alt="" coords="288,5,515,31"/>
<area shape="rect" href="memory__manager_8c.html#a2250996fd809506caef0a6e61b6faebb" title=" " alt="" coords="109,5,240,31"/>
<area shape="poly" title=" " alt="" coords="274,21,240,21,240,15,274,15"/>
<area shape="rect" href="memory__manager_8c.html#ae075bb556abb4342aedf495ddb8d390a" title="Frees memory allocated by the memory manager." alt="" coords="5,5,61,31"/>
<area shape="poly" title=" " alt="" coords="96,21,61,21,61,15,96,15"/>
</map>
</div>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0
</small></address>
</body>
</html>
